<!DOCTYPE HTML5>

<html>

  <head>

    <title>TRON | Thomas Yung</title>
    <link rel="stylesheet" href="../css/article.css"/>
    <link href="https://fonts.googleapis.com/css?family=Bitter:400,700"
                                                               rel="stylesheet">
    <script src="../scripts/blogScript.js"></script>

  </head>


  <body>
    <div id="pagewrapper">

      <div id="menubar">
        <table>
          <tbody>
            <tr>

              <td>
                <h3><a onmouseover="addLine('home')"
                       onmouseleave="remLine('home')"
                       onclick="toggleSection('home')"
                       href="../index.html">
                        <div id="home-o" class="line"></div>
                        Home
                        <div id="home-u" class="line"></div>
                    </a>
                </h3>
              </td>

              <td>
                <h3><a onmouseover="addLine('articlelist')"
                       onmouseleave="remLine('articlelist')"
                       onclick="toggleSection('articlelist')"
                       href="../blog.html">
                        <div id="articlelist-o" class="line"></div>
                        Article List
                        <div id="articlelist-u" class="line"></div>
                    </a>
                </h3>
              </td>

            </tr>
          </tbody>

        </table>
      </div>

      <div id="contentwrapper">
         <p class="textholder">
           <a href="https://github.com/thomas-yung/tron">GitHub link</a>
           <br />
           <br />
           At the end of my first year at Imperial, I partook in a group project (along with <a href=””>Shashwat Dalal</a>, <a href=””>Marcel Kenlay</a> and <a href=””>Andy Li</a>) which saw us create an ARM emulator, assembler and lastly a group extension which we chose to be our own implementation of the classic <i>TRON</i> arcade game.
           <br />
           For the emulator and assembler, we followed a specification outlined to us however the game was our own choosing. Since we only had a week to create the product from start to finish (along with writing a report and presentation for all parts) we divided the tasks amongst team members to ensure we could arrive at a completed product. Whilst what we finished was received well by the assessors, I only worked on sections of the code and wanted to experience using the graphics library and also design my own AI opponent.
           <br />
           The AI schemas are discusssed below.
           <br />
           Another decision I had to make was between the use of <i>OpenGL</i> and <i>SDL</i> as my graphics library. The group-completed version of the game used <i>OpenGL</i> however I found it to be overkill for a 2D game such as <i>TRON</i>. Fortunately the jump to <i>SDL</i> was easy and it is well documented online. In many ways, completely rewriting the code was forced by my decision to switch graphics libraries as the way each works is very different. In my case, <i>SDL</i> has a very 'step-by-step' approach whereby I can explicitly update the board and then display it. In my opinion this is a very clear way to structure a simple game and it made debugging very painless.
           <br />
           <br />
           <b>Approach 1: Random valid move</b>
           <br />
           I would very loosely describe this as an artificial <i>intelligence</i>. This was more of a way to simply test whether or not the game was funciioning and computer chosen moves worked correctly. Quite simply, the computer randomly picks one of the three moves available to the player (turning back on one's self is not an option).
           <br />
           It is somewhat obvious that this opponent eliminated itself very quickly so a buffer was added so that it would continue straight for a user input proportion of the time. This buffer was implemented by randomly generating a number from 0 to 100 and if it is less that the user's limit then the player turns randomly (note: a turn includes continuing straight).
           <br />
           <br />
           <b>Approach 2: Random survival move</b>
           <br />
           This appoarch started life as a helper method for the next approach however I thought I may as well use it as it's own AI to be able to test if it worked. In this case, turns can be forced and picked from the same list of valid moves that approach 1 yields. This time the computer checks to see if there are any occupants of the hyperthetical destination cell before moving. The forcing of turns avoided it hitting other players more and going out of bounds.
           <br />
           <br />
           <b>Approach 3: Most immediate space</b>
           <br />
           Now the computer starts to think *slightly* more intelligently. Here I introduced the idea of scoring possibilities by assiging a score for each possible turn. The score is how many unoccupied cells there are in a chain from the current position if the player continued in a straight line. Although this does not avoid enclosing one's self or being enclosed, it preforms massivly better than approach 2. This does lead to a more boring AI which tends to turn less often. To spice up the movement, I multiply each turn score by a number between 1.0 and 1.5 so that the movement isn't deterministic but the value of the scores isn't lost.
         </p>
      </div>

    </div>
  </body>

</html>
