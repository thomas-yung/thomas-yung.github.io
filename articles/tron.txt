At the end of my first year at Imperial, I partook in a group project (along with <a href=””>Shashwat Dalal</a>, <a href=””>Marcel Kenlay</a> and <a href=””>Andy Li</a>) which saw us create an ARM emulator, assembler and lastly a group extension which we chose to be our own implementation of the classic <i>TRON</i> arcade game.
<br />
For the emulator and assembler, we followed a specification outlined to us however the game was our own choosing. Since we only had a week to create the product from start to finish (along with writing a report and presentation for all parts) we divided the tasks amongst team members to ensure we could arrive at a completed product. Whilst what we finished was received well by the assessors, I only worked on sections of the code and wanted to experience using the graphics library and also design my own AI opponent.
<br />
The AI schemas are discusssed below.
<br />
<h4>Approach 1: Random valid move</h4>
<p>I would very loosely describe this as an artificial <i>intelligence</i>. This was more of a way to simply test whether or not the game was funciioning and computer chosen moves worked correctly. Quite simply, the computer randomly picks one of the three moves available to the player (turning back on one's self is not an option).
<br />
It is somewhat obvious that this opponent eliminated itself very quickly so a buffer was added so that it would continue straight for a user input proportion of the time. This buffer was implemented by randomly generating a number from 0 to 100 and if it is less that the user's limit then the player turns randomly (note: a turn includes continuing straight).
</p>
<h4>Approach 2: Random survival move</h4>
<p>This appoarch started life as a helper method for the next approach however I thought I may as well use it as it's own AI to be able to test if it worked. In this case, turns can be forced and picked from the same list of valid moves that approach 1 yields. This time the computer checks to see if there are any occupants of the hyperthetical destination cell before moving. The forcing of turns avoided it hitting other players more and going out of bounds.
</p>
<h4>Approach 3: Most direct space</h4>
<p>Now the computer starts to think *slightly* more intelligently. Here I introduced the idea of scoring possibilities by assiging a score for each possible turn. The score is how many unoccupied cells there are in a chain from the current position if the player continued in a straight line. Although this does not avoid enclosing one's self or being enclosed, it preforms massivly better than approach 2. This does lead to a more boring AI which tends to turn less often. To spice up the movement, I multiply each turn score by a number between 1.0 and 1.5 so that the movement isn't deterministic but the value of the scores isn't lost.
</p>
